#动态库和静态库及其加载方式
--------------------
##库的格式
一般Linux和windows上的库的格式内容大概差不多，Windows上的是PE格式（.dll，.lib），linux上的是ELF格式(.so, .a)。他们和目标文件(.o)的格式基本上都是差不多的。

elf格式：
ELF header 地址为0 (elf 文件头)
.text(函数地址) ——|
.rodate（const 常量，字符串）      |
.data （未初始化全局变量）       |
.bss （已初始化全局变量）        |
.symtab（符号表，描述（简写）函数，变量的一串长字符串（编译器的不同，符号表也会不同）      |   section(每一节的内容)
.rel.text    |
.rel.data    |
.debug       |
.line        |
.strlab      ——|
section head | section的节头

debug版本
        
debug_info   |
debug_line   | for debug
debug_str    |
debug_arangs |


这里加一段我自己的理解，格式一般都是函数，全局变量，常量，类，静态函数，那么一般目标文件里面的内容不就是函数，变量的地址以及函数的展开。（堆，栈，静态变量区，常量只读区，代码段）。
（符号表记录的是变量或者函数的基本信息，例如变量的大小，是不是全局还是局部，名字变量的值类型{是变量（字符串，整形），还是函数}等）

动态库 /动态加载（动态链接），静态加载（静态链接）
----------------
Linux下以.so结尾，windows下以.dll结尾.动态库的动态加载程序运行的时候才会把动态库里面的内容映射到虚拟内存里面去。cpu指令寄存器就会执行入口地址。映射的虚拟内存里面没有数据，会产生页错误。cpu把寄存器的控制权交给操作系统，操作系统会根据映射大小申请物理内存页，之后把动态库里面的内容读取到物理内存里面（数据结构体）。最后cup会执行相关指令。
动态加载的优点：程序模块化，代码占用内存小。（边运行边加载）
缺点：处理静态变量，全局变量等比较容易出现问题。例如：应用程序退出的时候静态变量释放的问题。





静态库 / 静态加载（静态链接）
----------
程序编译的时候把相关的目标文件关联到一起生成(linux下生成.a文件，windows下生成lib文件)，最后链接的时候，链接器会把静态库里面的所有东西复制到可执行文件里面去。（相关目标文件的集合）。（静态链接）
缺点是会导致可执行文件文件很大，迭代升级不方便。
有的是程序运行效率高，速度快。

##G++编译相关文件为动态库直接加载
gcc/g++的编译参数

```
     ld:链接器，把目标文件链接成可执行文件

     -E： 预处理文件  

     -S 编译成汇编代码 

     -c变成目标文件

     -o 生成相关文件
 
     -L ：表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。


     -l (L的小写)：表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test

     -include ：包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。

     -I (i 的大写)：指定头文件的所在的目录，可以使用相对路径。

     -shared ：指定生成动态链接库

     -fPIC：  表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入实时通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。

```
####一般链接-L+目录 -l+库的名称

#####注意：库的名称格式规定为libxxx.a/libxxx.so
有a.cc a.h main.cc 三个文件。
gcc -E a.cc -o &>a.txt------>这里预处理的数据会直接答应出来，所以重定位到文件里。
gcc -S a.cc  ---->这里会生成a.s文件
gcc -c a.cc ----->这里会生成a.o文件
gcc a.o main.o -o main --->生成可执行文件 //这里也可以用ld main.o a.o -o main (链接会报错 加上gcc -v a.cc 需要找到最后一行collect2（他是ld的封装） 相关命令加上去) 


####编译动态库，动态链接
gcc -shared -fPIC a.cc -o liba.so (把a.cc编译成动态库)
gcc main.cc -La -o main(链接动态库生成可执行文件)
这里执行main会提示找不到动态库，是因为我们的环境没有被添加进去 使用export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH添加环境

####编译静态库，静态链接
ar（linux下打包指令，可以生成静态库）
ar cqs -o liba.a a.cc
g++ -o main main.cc -L. -la
直接运行没问题



