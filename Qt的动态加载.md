#动态库和静态库及其加载方式
--------------------
##库的格式
一般Linux和windows上的库的格式内容大概差不多，Windows上的是PE格式（.dll，.lib），linux上的是ELF格式(.so, .a)。他们和目标文件(.o)的格式基本上都是差不多的。

elf格式：
ELF header 地址为0 (elf 文件头)
.text(函数地址) ——|
.rodate（const 常量，字符串）      |
.data （未初始化全局变量）       |
.bss （已初始化全局变量）        |
.symtab（符号表，描述（简写）函数，变量的一串长字符串（编译器的不同，符号表也会不同）      |   section(每一节的内容)
.rel.text    |
.rel.data    |
.debug       |
.line        |
.strlab      ——|
section head | section的节头

debug版本
        
debug_info   |
debug_line   | for debug
debug_str    |
debug_arangs |


这里加一段我自己的理解，格式一般都是函数，全局变量，常量，类，静态函数，那么一般目标文件里面的内容不就是函数，变量的地址以及函数的展开。（堆，栈，静态变量区，常量只读区，代码段）。
（符号表记录的是变量或者函数的基本信息，例如变量的大小，是不是全局还是局部，名字变量的值类型{是变量（字符串，整形），还是函数}等）

动态库 /动态加载（动态链接），静态加载（静态链接）
----------------
Linux下以.so结尾，windows下以.dll结尾.动态库的动态加载程序运行的时候才会把动态库里面的内容映射到虚拟内存里面去。cpu指令寄存器就会执行入口地址。映射的虚拟内存里面没有数据，会产生页错误。cpu把寄存器的控制权交给操作系统，操作系统会根据映射大小申请物理内存页，之后把动态库里面的内容读取到物理内存里面（数据结构体）。最后cup会执行相关指令。
动态加载的优点：程序模块化，代码占用内存小。（边运行边加载）
缺点：处理静态变量，全局变量等比较容易出现问题。例如：应用程序退出的时候静态变量释放的问题。





静态库 / 静态加载（静态链接）
----------
程序编译的时候把相关的目标文件关联到一起生成(linux下生成.a文件，windows下生成lib文件)，最后链接的时候，链接器会把静态库里面的所有东西复制到可执行文件里面去。（相关目标文件的集合）。（静态链接）
缺点是会导致可执行文件文件很大，迭代升级不方便。
有的是程序运行效率高，速度快。